<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>simuclustfactor.utils &mdash; simuclustfactor 0.0.3 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> simuclustfactor
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">simuclustfactor</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">simuclustfactor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>simuclustfactor.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for simuclustfactor.utils</h1><div class="highlight"><pre>
<span></span><span class="c1">### -------------------</span>

<span class="c1"># Helping functions to </span>

<span class="c1">### -------------------</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># =========== 1 RUN OF THE KMEANS ALGORITHM</span>

<div class="viewcode-block" id="OneKMeans"><a class="viewcode-back" href="../../simuclustfactor.html#simuclustfactor.utils.OneKMeans">[docs]</a><span class="k">def</span> <span class="nf">OneKMeans</span><span class="p">(</span><span class="n">Y_i_qr</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">U_i_g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The OneKMeans function takes in the following parameters:</span>
<span class="sd">		- Y_i_qr: A matrix of the component scores.</span>
<span class="sd">		- G: The number of groups to cluster the objects into.</span>
<span class="sd">		- U_i_g=None (optional): A membership matrix for all objects, with each row representing an object and each column representing a group.</span>

<span class="sd">	:param ndarray Y_i_qr: Used to Store the data matrix for all objects.</span>
<span class="sd">	:param int G: Used to Define the number of clusters.</span>
<span class="sd">	:param ndarray U_i_g: Used to Pass in a membership matrix to the function.</span>
<span class="sd">	:param numpy rng: Used to Ensure that the results are reproducible.</span>
<span class="sd">	:param int seed: Used to Ensure that the results are reproducible.</span>
<span class="sd">	:return: A stochastic membership matrix (U_i_g), allocating each component score to a centroid in the reduced space is returned.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># defining random generator with no seed to radnom results.</span>
	<span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

	<span class="n">Y_i_qr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y_i_qr</span><span class="p">)</span>

	<span class="n">I</span> <span class="o">=</span> <span class="n">Y_i_qr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="c1"># initialize centroids matrix</span>
	<span class="k">if</span> <span class="n">U_i_g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">U_i_g</span> <span class="o">=</span> <span class="n">RandomMembershipMatrix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">U_i_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U_i_g</span><span class="p">)</span>
	<span class="n">Y_g_qr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">U_i_g</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">@</span> <span class="n">U_i_g</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Y_i_qr</span>

	<span class="c1"># ------- case 1: repeat until no empty clustering	</span>
	<span class="n">U_i_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">I</span><span class="p">,</span><span class="n">G</span><span class="p">))</span>

	<span class="c1"># assign each object to the respective cluster</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">Y_i_qr</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">-</span><span class="n">Y_g_qr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># calculate distance between obj and centroids.</span>
		<span class="n">min_dist_cluster</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>  <span class="c1"># get cluster with smallest distancee from object.</span>
		<span class="n">U_i_g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">min_dist_cluster</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># assign the object to that cluster.</span>

	<span class="c1"># possibility of observing empty clusters</span>
	<span class="n">C_g</span> <span class="o">=</span> <span class="n">U_i_g</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># get count of members in each cluster</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">C_g</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
		<span class="n">LC</span> <span class="o">=</span> <span class="n">C_g</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>  <span class="c1"># select the largest cluster</span>
		<span class="n">EC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">C_g</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># select next empty cluster</span>
		
		<span class="n">LC_members</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">U_i_g</span><span class="p">[:,</span><span class="n">LC</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

		<span class="n">LC_scores</span> <span class="o">=</span> <span class="n">Y_i_qr</span><span class="p">[</span><span class="n">LC_members</span><span class="p">,]</span>
		<span class="n">U_i_g</span> <span class="o">=</span> <span class="n">_split_update</span><span class="p">(</span><span class="n">LC</span><span class="p">,</span> <span class="n">LC_members</span><span class="p">,</span> <span class="n">LC_scores</span><span class="p">,</span> <span class="n">EC</span><span class="p">,</span> <span class="n">U_i_g</span><span class="p">,</span> <span class="n">C_g</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>  <span class="c1"># splitting cluster into 2 sub-clusters and updating U_i_g</span>

		<span class="n">C_g</span> <span class="o">=</span> <span class="n">U_i_g</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># ensure the alg stops</span>

	<span class="k">return</span> <span class="n">U_i_g</span></div>


<span class="k">def</span> <span class="nf">_split_update</span><span class="p">(</span><span class="n">LC</span><span class="p">,</span> <span class="n">LC_members</span><span class="p">,</span> <span class="n">LC_scores</span><span class="p">,</span> <span class="n">EC</span><span class="p">,</span> <span class="n">U_i_g</span><span class="p">,</span> <span class="n">C_g</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The split_update function takes in the following parameters:</span>
<span class="sd">		- LC: The index of the largest cluster.</span>
<span class="sd">		- EC: The index of the empty cluster.</span>
<span class="sd">		- U_i_g: A membership matrix for all objects, with each row representing an object and each column representing a group.</span>
<span class="sd">	</span>
<span class="sd">		It then performs these operations to reassign objects to new clusters based on their distance from subcluster centroids (Y_2):</span>
<span class="sd">			- M = number of objects in largest cluster.</span>
<span class="sd">			- Find indices for all members of largest cluster.</span>
<span class="sd">			- Initialize a 2xQR centroids matrix Y_2 for subclusters using random initialization.</span>
<span class="sd">			- Allocate members to closest centroids.</span>
<span class="sd">	</span>
<span class="sd">		It returns the updated membership function matrix u_i_g.</span>
<span class="sd">	</span>
<span class="sd">	:param LC: Used to Select the largest cluster.</span>
<span class="sd">	:param LC_members: Used to Store the indices of all objects in the largest cluster.</span>
<span class="sd">	:param LC_scores: Used to Store the scores of each cluster.</span>
<span class="sd">	:param EC: Used to Store the index of the empty cluster.</span>
<span class="sd">	:param U_i_g: Used to Assign each object to a cluster.</span>
<span class="sd">	:param C_g: Used to Store the index of the largest cluster.</span>
<span class="sd">	:param seed: Used to Initialize the random number generator.</span>
<span class="sd">	:return: The updated membership matrix u_i_g.</span>
<span class="sd">	</span>
<span class="sd">	:doc-author: Trelent</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">LC_members</span><span class="p">)</span>  <span class="c1"># number of objects in the largest cluster.</span>

	<span class="c1"># perform K-means to split members of LC into 2 clusters and update U_i_g matrix</span>
	<span class="n">U_m_2</span> <span class="o">=</span> <span class="n">RandomMembershipMatrix</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># initialize matrix with 2 groups</span>
	<span class="n">Y_2_qr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">U_m_2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">@</span> <span class="n">U_m_2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">LC_scores</span>   <span class="c1"># 2xQR centroids matrix for subclusters</span>

	<span class="c1"># assign each cluster member to the respective sub-cluster</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LC_scores</span><span class="p">)):</span>

		<span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">LC_scores</span><span class="p">[</span><span class="n">i</span><span class="p">,]</span><span class="o">-</span><span class="n">Y_2_qr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># calculate distance between obj and the 2 sub-centroids.</span>
		<span class="n">min_dist_cluster</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>  <span class="c1"># get cluster with smallest distance.</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">min_dist_cluster</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
			<span class="n">U_i_g</span><span class="p">[</span><span class="n">LC_members</span><span class="p">[</span><span class="n">i</span><span class="p">],]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># unassign the obj from the large cluster.</span>
			<span class="n">U_i_g</span><span class="p">[</span><span class="n">LC_members</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">EC</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># assign the obj to the empty cluster.</span>

	<span class="k">return</span> <span class="n">U_i_g</span>


<span class="c1"># =========== BUILDING MEMBERSHIP FUNCTION MATRIX CONSTRUCTION</span>

<div class="viewcode-block" id="RandomMembershipMatrix"><a class="viewcode-back" href="../../simuclustfactor.html#simuclustfactor.utils.RandomMembershipMatrix">[docs]</a><span class="k">def</span> <span class="nf">RandomMembershipMatrix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The RandomMembershipMatrix function creates a random membership matrix U_i_g. </span>
<span class="sd">	The function takes as input the number of objects I and the number of clusters G, </span>
<span class="sd">	and returns a matrix U_i_g with dimensions (I x G) where each row is an object, and each column is a cluster. </span>
<span class="sd">	The first G rows are assigned to unique clusters 0 through G-2. The last I-G rows are randomly assigned to one of the existing clusters.</span>
<span class="sd">	</span>
<span class="sd">	:param int I: Used to define the number of objects in the dataset.</span>
<span class="sd">	:param int G: Used to define the number of clusters.</span>
<span class="sd">	:param generator rng: Used to specify the random number generator.</span>
<span class="sd">	:param int seed: Used to ensure that the results are random.</span>
<span class="sd">	:return: A binary stochastic matrix allocating objects to a cluster.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="c1"># defining random generator with no seed to radnom results.</span>
	<span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

	<span class="c1"># initialize U_i_g</span>
	<span class="n">U_i_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">I</span><span class="p">,</span><span class="n">G</span><span class="p">))</span>
	<span class="n">U_i_g</span><span class="p">[:</span><span class="n">G</span><span class="p">,]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># first G assignments to unique clusters. To ensure no cluster is empty</span>

	<span class="c1"># assign random clusters to remaining objects</span>
	<span class="k">if</span> <span class="n">I</span> <span class="o">&gt;</span> <span class="n">G</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">I</span><span class="p">):</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># choose a random cluster for the i&#39;th object.</span>
			<span class="n">U_i_g</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># assign object p to cluster c</span>

	<span class="k">return</span> <span class="n">U_i_g</span></div>

<span class="c1"># ===========  END OF MEMBERSHIP FUNCTION CONSTRUCTION</span>


<span class="c1"># ===========  LARGEST EIGENVECTORS</span>

<div class="viewcode-block" id="EigenVectors"><a class="viewcode-back" href="../../simuclustfactor.html#simuclustfactor.utils.EigenVectors">[docs]</a><span class="k">def</span> <span class="nf">EigenVectors</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The EigenVectors function takes in a matrix X and the number of desired eigenvectors D.</span>
<span class="sd">	It returns the first D eigenvectors of X, sorted by their corresponding eigenvalues.</span>
<span class="sd">	eigh instead of eig because of truncation errors with numpy&#39;s implementtation which could </span>
<span class="sd">	result in incorrect result (eg. complex vectors for covariance matrices)</span>


<span class="sd">	:param ndarray X: Used to Calculate the eigenvectors of x.</span>
<span class="sd">	:param int D: Used to Specify the number of eigenvectors to return.</span>
<span class="sd">	:return: The eigenvectors of the covariance matrix.</span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="c1"># U,_,_ = np.linalg.svd(X)</span>
	<span class="c1"># return U[:,:D]</span>

	<span class="n">eigenValues</span><span class="p">,</span><span class="n">eigVectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
	<span class="c1"># eigenValues,eigVectors = np.linalg.eig(X)</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">eigenValues</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  
	<span class="n">eigenValues</span> <span class="o">=</span> <span class="n">eigenValues</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">eigVectors</span><span class="p">[:,:</span><span class="n">D</span><span class="p">]</span></div>

<span class="c1"># ===========  END OF LARGEST EIGENVECTORS</span>


<span class="c1"># ===========  START OF THE PseudoF STATISTIC IN FULL &amp; REDUCED spaces</span>

<div class="viewcode-block" id="PseudoF_Full"><a class="viewcode-back" href="../../simuclustfactor.html#simuclustfactor.utils.PseudoF_Full">[docs]</a><span class="k">def</span> <span class="nf">PseudoF_Full</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span> <span class="n">wss</span><span class="p">,</span> <span class="n">full_tensor_shape</span><span class="p">,</span> <span class="n">reduced_tensor_shape</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The PseudoF function is a measure of the ratio between the amount of </span>
<span class="sd">	variance explained by a model with `rank` components, and the variance </span>
<span class="sd">	explained by an optimal model with `tensor_shape` dimensions. This function </span>
<span class="sd">	is used to select an appropriate rank for a tensor decomposition.</span>
<span class="sd">	</span>
<span class="sd">	:param bss: Between cluster sum of squares deviance.</span>
<span class="sd">	:type bss: float</span>
<span class="sd">	:param wss: Within cluster sum of squares deviance.</span>
<span class="sd">	:type wss: float</span>
<span class="sd">	:param full_tensor_shape: (I,J,K) tensor dimensions.</span>
<span class="sd">	:type full_tensor_shape: tuple</span>
<span class="sd">	:param reduced_tensor_shape: (G,Q,R) G clusters, Q components for variables, R components for Occasions.</span>
<span class="sd">	:type reduced_tensor_shape: tuple</span>
<span class="sd">	:return: The pseudo-f statistic for the given tensor and rank.</span>
<span class="sd">	:rtype: float</span>
<span class="sd">	</span>
<span class="sd">	Reference:</span>
<span class="sd">		[1] Roberto Rocci and Maurizio Vichi (2005).</span>
<span class="sd">		Three-mode component analysis with crisp or fuzzy partition of units. </span>
<span class="sd">		Psychometrika, 70:715–736, 02 2005.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">full_tensor_shape</span>
	<span class="n">G</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">reduced_tensor_shape</span>
	<span class="n">db</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">Q</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span><span class="o">-</span><span class="n">R</span><span class="p">)</span><span class="o">*</span><span class="n">R</span>
	<span class="n">dw</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">K</span> <span class="o">-</span> <span class="p">(</span><span class="n">G</span><span class="o">*</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">Q</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span><span class="o">-</span><span class="n">R</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bss</span><span class="o">/</span><span class="n">db</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wss</span><span class="o">/</span><span class="n">dw</span><span class="p">)</span></div>


<div class="viewcode-block" id="PseudoF_Reduced"><a class="viewcode-back" href="../../simuclustfactor.html#simuclustfactor.utils.PseudoF_Reduced">[docs]</a><span class="k">def</span> <span class="nf">PseudoF_Reduced</span><span class="p">(</span><span class="n">bss</span><span class="p">,</span> <span class="n">wss</span><span class="p">,</span> <span class="n">full_tensor_shape</span><span class="p">,</span> <span class="n">reduced_tensor_shape</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	The PseudoF function is a measure of the ratio between the amount of </span>
<span class="sd">	variance explained by a model with `rank` components, and the variance </span>
<span class="sd">	explained by an optimal model with `tensor_shape` dimensions. Computes</span>
<span class="sd">	the PseudoF score without taking into account any contraints. </span>
<span class="sd">	The naive implementation.</span>
<span class="sd">	</span>
<span class="sd">	:param bss: Between cluster sum of squares deviance.</span>
<span class="sd">	:type bss: float</span>
<span class="sd">	:param wss: Within cluster sum of squares deviance.</span>
<span class="sd">	:type wss: float</span>
<span class="sd">	:param full_tensor_shape: (I,J,K) tensor dimensions.</span>
<span class="sd">	:type full_tensor_shape: tuple</span>
<span class="sd">	:param reduced_tensor_shape: (G,Q,R) G clusters, Q components for variables, R components for Occasions.</span>
<span class="sd">	:type reduced_tensor_shape: tuple</span>
<span class="sd">	:return: The pseudo-f statistic for the given tensor and rank.</span>
<span class="sd">	:rtype: float</span>
<span class="sd">	</span>
<span class="sd">	Reference:</span>
<span class="sd">		[1] T. Caliński &amp; J Harabasz (1974).</span>
<span class="sd">		A dendrite method for cluster analysis</span>
<span class="sd">		Communications in Statistics, 3:1, 1-27, DOI: 10.1080/03610927408827101</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">full_tensor_shape</span>
	<span class="n">G</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">reduced_tensor_shape</span>
	<span class="n">db</span> <span class="o">=</span> <span class="n">G</span><span class="o">-</span><span class="mi">1</span>
	<span class="n">dw</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">Q</span><span class="o">*</span><span class="n">R</span> <span class="o">-</span> <span class="n">G</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bss</span><span class="o">/</span><span class="n">db</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wss</span><span class="o">/</span><span class="n">dw</span><span class="p">)</span></div>

<span class="c1"># ===========  END OF PseudoF STATISTIC FUNCTION</span>


<span class="c1"># ===========  START OF _BASECLASS</span>

<span class="k">class</span> <span class="nc">_BaseClass</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Base class for the tandem tucker-factorial and kmeans-clustering models.</span>
<span class="sd">	For checking initialization configuration.</span>
<span class="sd">	</span>
<span class="sd">	:param bool verbose: whether to display executions output or not. Defaults to False.</span>
<span class="sd">	:param str init: the parameter initialization method. Defaults to svd.</span>
<span class="sd">	:param int seed: seed for random sequence generation. Defaults to None.</span>
<span class="sd">	:param int n_max_iter: maximum number of iterations. Defaults to 10.</span>
<span class="sd">	:param int n_loops: number of random initializations to gurantee global results. Defaults to 10.</span>
<span class="sd">	:param float tol: tolerance level/acceptable error. Defaults to 1e-5.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span>
		<span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		<span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
		<span class="n">init</span><span class="o">=</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span>
		<span class="n">n_max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
		<span class="n">n_loops</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
		<span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
		<span class="n">U_i_g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		<span class="n">B_j_q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		<span class="n">C_k_r</span><span class="o">=</span><span class="kc">None</span>
	<span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">n_max_iter</span> <span class="o">=</span> <span class="n">n_max_iter</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">n_loops</span> <span class="o">=</span> <span class="n">n_loops</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (I,J,K)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># (G,Q,R)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">B_j_q</span> <span class="o">=</span> <span class="n">B_j_q</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">C_k_r</span> <span class="o">=</span> <span class="n">C_k_r</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">U_i_g</span> <span class="o">=</span> <span class="n">U_i_g</span>

	<span class="c1"># Check initialization configurations.</span>
	<span class="k">def</span> <span class="nf">_check_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		verify valid input tensor dimensions in the full and reduced space.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># n_max_iter</span>
		<span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_max_iter</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_max_iter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_max_iter should be &gt; 0, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_max_iter</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>

		<span class="c1"># tol</span>
		<span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
				<span class="sa">f</span><span class="s2">&quot;tolerance should be very small positive number between &lt; 1 but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="si">}</span><span class="s2">&quot;</span>
			<span class="p">)</span>

		<span class="c1"># verbose</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
				<span class="sa">f</span><span class="s2">&quot;verbose must be boolean but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
			<span class="p">)</span>

		<span class="c1"># ensure all dimensions given are greater than 0</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
				<span class="sa">f</span><span class="s2">&quot;reduced_tensor_shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="si">}</span><span class="s2"> must be &lt;= full_tensor_shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="si">}</span><span class="s2">.&quot;</span>
			<span class="p">)</span>

	<span class="c1"># component matrices validation</span>
	<span class="k">def</span> <span class="nf">_check_initialized_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		If U_i_g,B_j_q and C_k_r are user-defined, dimensions of these matrices are validated.</span>
<span class="sd">		U_i_g must also be row-stochastic (row-sums equal to 1)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># check U membership matrix</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_i_g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="c1"># check dimension</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_i_g</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
					<span class="sa">f</span><span class="s2">&quot;incorrect U_i_g matrix, expected shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">U_i_g</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
				<span class="p">)</span>
			
			<span class="c1"># check row stochastic nature</span>
			<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_i_g</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
					<span class="sa">f</span><span class="s2">&quot;incorrect U_i_g matrix. U_i_g must be row stochastic.&quot;</span>
				<span class="p">)</span>

		<span class="c1"># check B component matrix</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_j_q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="c1"># check dimension</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_j_q</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
					<span class="sa">f</span><span class="s2">&quot;incorrect B_j_q matrix, expected shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">B_j_q</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
				<span class="p">)</span>
		
		<span class="c1"># check C component matrix</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_k_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="c1"># check dimension</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_k_r</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
					<span class="sa">f</span><span class="s2">&quot;incorrect C_k_r matrix, expected shape </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_tensor_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_tensor_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">C_k_r</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
				<span class="p">)</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Prosper Ablordeppey.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>